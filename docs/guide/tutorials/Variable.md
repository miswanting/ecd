# 常量与变量

## 前言与确认

简单的输出文字虽然是开发游戏的必由之路，但仅仅局限于此，决不是任何优秀的开发者所追求的目标。

制作游戏不是写小说，仅仅靠在脚本中挥洒文采只能让玩家变成“一次性的读者”。因此，我们就需要给游戏中的**信息**施加名为“变化”的魔法。而实现这一点的基础，就需要首先学习如何“指代”**信息**。

::: warning 教程依赖

本教程假设您已学习过[快速开始](../Quick_Start)。若您尚未学习过，我们强烈推荐您首先学习相应教程。

:::

先确认一下我们现有的工程文件夹结构：

```
root/
 ├─ emuera.config
 ├─ Emuera1824.exe
 ├─ CSV/
 └─ ERB/
     └─ System.erb
```

其中，`System.erb`的代码为：

```erb
@EventFirst
  Print Hello World!
  Quit
```

## 变量的概念、定义与打印

首先，我们举一个很日常的例子：我的包里有3个石头，我把石头的数量打印到屏幕上：`Print 3`。同时、我包里还有3个苹果，我把苹果的数量也打印到屏幕上：`Print 3`，这样我们就得到一个脚本：

```erb{2-3}
@EventFirst
  Print 3
  Print 3
  Quit
```

现在我扔掉了一个石头，也就是需要将石头的数量变为`2`，再打印出来。

……

怎么做？游戏引擎和一些记忆力不太好的开发者就产生了迷惑：”究竟哪个3是石头的数量，而哪个3是苹果的数量呢？“

为了解决这个问题，我们在脚本语言中引入了**变量**这个概念。

你可以把变量看作是一个“有名字的容器”。而这个容器是能够装载东西的。

我们可以产生一个名称为`Stone`的容器，并将数值`3`装进去。用脚本表示就像这样：

```erb
#Dim Stone = 3
```

同理，苹果可以这样表示：

```erb
#Dim Apple = 3
```

这样，我们前面的脚本就可以等效于：

```erb{2-5}
@EventFirst
  #Dim Stone = 3
  #Dim Apple = 3
  PrintV Stone
  PrintV Apple
  Quit
```

细心的同学也许会发现：原来脚本里的`Print`关键字现在变成了`PrintV`关键字，这是为什么呢？[更多](/reference/ERB_Commands.html#print-v-s-form-forms-k-d-l-w)

其实，这个多出来的`V`就是英语 **变量“Variable”** 的缩写。相比于`Print`直接打印后面的原始文本，`PrintV`会打印后面的变量所装载的值。

简单举例：

```
Print Stone
PrintV Stone
```

放在上面的脚本上下文中会输出：

```
Stone3
```

十分简单就可以理解。

言归正传。我们已经为石头和苹果定义了变量，并获得了与前面的脚本等效的新脚本，在这样的情况下，我们前面所遇到的更新信息的问题就能够迎刃而解。

修改石头的值，得到完整脚本：

```erb{4}
@EventFirst
  #Dim Stone = 3
  #Dim Apple = 3
  Stone = 2
  PrintV Stone
  PrintV Apple
  Quit
```

得到输出：

```
23
```

成功！

让我们详细地看看发生了什么：

- `#Dim Stone = 3`
  - 我们用`#Dim`命令定义了一个**变量**，名称为`Stone`，并使用`=`符号将`3`装入其中；
- `#Dim Apple = 3`
  - 我们用`#Dim`命令定义了一个**变量**，名称为`Apple`，并使用`=`符号将`3`装入其中；
- `Stone = 2`
  - 修改`Stone`变量的值，使其变为`2`；
- `PrintV Stone`
  - 我们使用`PrintV`命令将变量名为`Stone`的值输出到屏幕上；
- `PrintV Apple`
  - 我们使用`PrintV`命令将变量名为`Apple`的值输出到屏幕上；

是不是特别简单就能理解？通过定义一个”有名字的容器“，并将没有额外信息的“值”装入其中，我们就具有了操作值的基础工具——至少我们知道了某个值的名字`:)`。

而这个“容器”，我们就称为**变量**。

显而易见，一个**变量**至少由两个部分组成：**变量名**和**值**。

这部分很简单，不再赘述。

## 常量的概念、定义与打印

**常量**是一种“不可改变的”**变量**。

::: warning 待讨论的话题

一般来说，常量相比于变量，缺少了值的修改功能，但能够提高代码执行的性能；

但我猜想，具体到 Erabasic 游戏脚本上，引擎是否能够为常量提供相比于变量更低的性能开销，还不能肯定。

因此，我目前对 Erabasic 常量的看法是：

> 是来自其他语言的概念残留，脚本中可不使用该特性。

这个观点欢迎大家探讨，也欢迎大家从源码分析和 Benchmark 两个角度来论证。

若猜想证实，未来文档会对常量进行如下处理：

- 削减常量相关内容的占比；
- 避免在示例脚本中用到常量相关的内容；
- 在 MCS 代码风格中将常量特性列为不推荐；

以进一步平滑 Erabasic 的学习曲线。

:::

定义常量十分简单，完整脚本如下：

```erb
@EventFirst
  #Dim Const Stone = 0
  PrintV Stone
  Quit
```

其中`Const`关键字就代表定义类型为常量。

若尝试对常量的值进行修改，如：

::: warning 该代码含有可期待的错误

```erb
@EventFirst
#Dim Const Stone = 0
  Stone = 1
  PrintV Stone
  Quit
```

:::

会得到报错：

::: danger 错误信息<a href="javascript:alert('TODO')">索引</a>

> 代入文の左辺に変更できない変数を指定することはできません

你不能在赋值语句的左边指定一个不能改变的变量

:::

基本上就是这样。
